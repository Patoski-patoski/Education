# Why and what is JavaScript Web Token(JWT) authentication method

JWT, or JSON Web Token, is a compact, URL-safe token format used in web
authentication to securely transmit information between parties. It is widely
used for user authentication, authorization, and information exchange in web
applications.
I find it funny that JWT is pronounced as 'jot'. All of my life I've been
pronouncing it as 'jewt' üòè

Here‚Äôs how JWT works and why it is a popular choice in web authentication:

## What is a JWT?

A JWT is a JSON object that is encoded and signed to verify its integrity
and authenticity. It consists of three parts:

* `Header`:    The first specifies the type of token (JWT) and the signing
               algorithm (e.g., HMAC SHA256 or RSA).
* `Payload`:   The second contains the claims, or the information being
               transmitted, such as user ID, roles, and permissions.
* `Signature`: The third validates the token‚Äôs integrity. This part is
               generated by hashing the encoded header and payload along with
               a secret key or public/private key pair.

The result of the token looks like this:

```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjM0NTY3ODkwLCJyb2xlIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

Each of the parts is encoded in base64 and separated by dots `(.)`.

## How JWT Works in Web Authentication

The JWT process in web authentication typically follows these steps:

### **Step 1: Client Logs In**

1. The client (such as a web app, Postman) sends a login request to the server
   with credentials (e.g., username and password).
2. The server verifies the credentials. If they are correct, it generates a
   JWT with specific claims about the user (e.g., user ID, role) and signs it
   with a secret key.

### **Step 2: Token is Sent to the Client**

3. The server sends the JWT back to the client, which stores it
   (often in local storage or cookies).

### **Step 3: Client Makes Authenticated Requests**

4. For each subsequent request, the client includes the JWT in the HTTP header
   (usually as a Bearer token in the Authorization header).

```bash
Authorization: Bearer <token>
```

### **Step 4: Server Verifies the JWT**

5. When the server receives a request with a JWT, it verifies the token by
   checking the signature and optionally the token's claims (e.g., expiration).

6. If valid, the server allows the request and can use the claims to determine
   what actions the user is authorized to perform. If the token is invalid or
   expired, the server rejects the request, usually prompting re-authentication.

## Key Benefits of Using JWT for Web Authentication

* **Stateless**: JWTs are self-contained and do not require server-side
  sessions, which means the server doesn‚Äôt need to store any session data.
* **Scalability**: Stateless tokens allow for easier horizontal scaling
  (adding more servers), as no session persistence is required across servers.

* **Flexibility** : JWTs can store custom claims, allowing them to be easily
  used for both authentication (who you are) and authorization (what you can do).

## 4. Security Considerations

* **Expiration**: JWTs should include an exp (expiration) claim to limit token
  validity.
* **Secret Management**: The signing key must be securely stored, as anyone
  with the key could forge tokens.
* **HTTPS**: Always use HTTPS to protect tokens in transit, as JWTs are often
  transmitted in headers.

### Code sample using Express Js

```JavaSCript
import jwt from 'jsonwebtoken';
import bcrypt from "bcrypt";
import express from "express";
import cookieParser from 'cookie-parser';

const app = express();
app.use(express.json());
app.use(cookieParser())

const userData = {};
const JWT_SECRET = ';,lmnyt6t7ye8u9i--x,,..8883';

app.post('/signup', async (req, res) => {
    const { username, password } = req.body;

    const hashedPassword = await bcrypt.hash(password, 10);
    userData.id = 1;
    userData.username = username;
    userData.password = hashedPassword;

    console.log('User signed up');
    res.status(201).json({ message: "Signup successfully" });
});

app.post('/login', async (req, res) => {
    const { password } = req.body;

    // Check if user data exists
    if (!userData || !userData.password) {
        return res.status(400).json({ message: "User not found. Please sign up first." });
    }

    const isPasswordValid = await bcrypt.compare(password, userData.password);
    if (!isPasswordValid) {
        return res.status(401).json({ message: "Invalid credentials" });
    }

    const token = jwt.sign({
        userId: userData.id,
        username: userData.username 
        },
        JWT_SECRET, { expiresIn: "1h" });

    // set the token as an HTTP-only cookie
    //Note: This will set the token as an HTTP-only cookie, which means it won‚Äôt be
    //accessible via JavaScript on the client side, adding a layer of security.
    res.cookie("token", token, {
        httpOnly: true,
        maxAge: 1000 * 60 * 60,
        secure: process.env.NODE_ENV === 'production',
    });

    res.json({ message: "Login successful" });
});

// Middleware to protect routes
function authenticateToken(req, res, next) {
    const token = req.cookies.token; // Get token from cookies

    if (!token) {
        return res.status(401).json({ message: "Access token missing or invalid" });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded; // Attach decoded user info to req object
        next(); // Pass control to the next handler
    } catch (err) {
        return res.status(403).json({ message: "Invalid token" });
    }
}

// Protected route example
app.get('/protected', authenticateToken, (req, res) => {
    res.json({ message: "This is protected data", user: req.user });
});

app.listen(3000, () => {
    console.log('Listening live at port 3000');
});

```
